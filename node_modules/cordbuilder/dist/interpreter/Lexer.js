"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lexer = exports.Token = exports.TokenKind = void 0;
const keywords_1 = require("../constants/keywords");
var TokenKind;
(function (TokenKind) {
    TokenKind[TokenKind["Keyword"] = 0] = "Keyword";
    TokenKind[TokenKind["String"] = 1] = "String";
    TokenKind[TokenKind["EndOfFile"] = 2] = "EndOfFile";
    TokenKind[TokenKind["NewLine"] = 3] = "NewLine";
})(TokenKind || (exports.TokenKind = TokenKind = {}));
class Token {
    constructor(kind, lexeme, line, position) {
        this.kind = kind;
        this.lexeme = lexeme;
        this.line = line;
        this.position = position;
    }
    print() {
        console.log(`[${TokenKind[this.kind]}] - "${this.lexeme}", pos: ${this.position} | line: ${this.line}`);
    }
}
exports.Token = Token;
class Lexer {
    constructor(source) {
        this.source = source;
        this.line = 1;
        this.column = 1;
        this.cursor = 0;
    }
    lex() {
        const tokens = [];
        while (!this.isEof()) {
            if (this.current.trim() == '')
                this.next();
            else if (this.current == "@" && this.peek(-1) !== '\\')
                tokens.push(this.readKeyword());
            else
                tokens.push(this.readString());
        }
        tokens.push(this.eof());
        return tokens;
    }
    eof() {
        return new Token(TokenKind.EndOfFile, '\0', this.line, this.column);
    }
    readKeyword() {
        this.next();
        let lexeme = "";
        while (!this.isEof() && this.current !== " " && this.current !== "\n") {
            lexeme += this.current;
            this.next();
        }
        if (keywords_1.KEYWORDS.includes(lexeme))
            return new Token(TokenKind.Keyword, lexeme, this.line, this.column);
        else
            throw new Error(`Invalid keyword has been provided: ${lexeme}`);
    }
    readString() {
        let lexeme = "";
        while (!this.isEof()) {
            if (this.current == "@" && this.peek(-1) !== '\\')
                break;
            lexeme += this.current;
            this.next();
        }
        return new Token(TokenKind.String, lexeme.trim().replace(/\\@/g, '@'), this.line, this.column);
    }
    isEof() {
        return this.cursor == this.source.length;
    }
    peek(offset) {
        return this.source[this.cursor + offset];
    }
    get current() {
        return this.source[this.cursor];
    }
    next() {
        this.cursor++;
        this.column++;
        if (this.current == "\n") {
            this.column = 1;
            this.line++;
        }
    }
}
exports.Lexer = Lexer;
